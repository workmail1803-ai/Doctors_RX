-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- ==========================================
-- 1. PROFILES (Linked to Auth)
-- ==========================================
create table profiles (
  id uuid references auth.users on delete cascade primary key,
  role text check (role in ('doctor', 'assistant')) default 'doctor',
  full_name text,
  clinic_details jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);

-- RLS: Profiles
alter table profiles enable row level security;
create policy "Users can view own profile" on profiles for select using (auth.uid() = id);
create policy "Users can update own profile" on profiles for update using (auth.uid() = id);

-- ==========================================
-- 2. MEDICINES (Master List)
-- ==========================================
create table medicines (
  id bigint generated by default as identity primary key,
  brand text not null,
  form text,
  generic_name text,
  strength text,
  company text,
  created_at timestamptz default now()
);

-- Indexes for performance
create index idx_medicines_brand on medicines(brand);

-- RLS: Medicines (Read-only for all auth users)
alter table medicines enable row level security;
create policy "Authenticated users can read medicines" on medicines for select to authenticated using (true);
-- Only service role can insert/update medicines for now

-- ==========================================
-- 3. PRESCRIPTIONS (Core Data)
-- ==========================================
create table prescriptions (
  id uuid default uuid_generate_v4() primary key,
  doctor_id uuid references auth.users(id) not null,
  patient_name text not null,
  patient_info jsonb default '{}'::jsonb, -- age, sex, weight, bp
  diseases jsonb default '[]'::jsonb,    -- Array of {name, days}
  meds jsonb default '[]'::jsonb,        -- Array of {name, dosage, freq, duration}
  tests jsonb default '[]'::jsonb,       -- Array of {name, notes}
  advice text,
  follow_up text,
  created_at timestamptz default now()
);

-- Indexes for Smart Search
-- Using GIN index for JSONB to allow searching inside the diseases array
create index idx_prescriptions_diseases on prescriptions using gin (diseases);
-- Index on doctor_id for RLS performance
create index idx_prescriptions_doctor_id on prescriptions(doctor_id);

-- RLS: Prescriptions
alter table prescriptions enable row level security;

-- Policy: Doctor can see ONLY their own prescriptions
create policy "Doctors can view own prescriptions" 
  on prescriptions for select 
  using (auth.uid() = doctor_id);

create policy "Doctors can insert own prescriptions" 
  on prescriptions for insert 
  with check (auth.uid() = doctor_id);

create policy "Doctors can update own prescriptions" 
  on prescriptions for update 
  using (auth.uid() = doctor_id);

create policy "Doctors can delete own prescriptions" 
  on prescriptions for delete 
  using (auth.uid() = doctor_id);

-- ==========================================
-- 4. PRESCRIPTION TEMPLATES (Print Layouts)
-- ==========================================
create table prescription_templates (
  id uuid default uuid_generate_v4() primary key,
  doctor_id uuid references auth.users(id) not null,
  header_html text,
  footer_html text,
  css_overrides text,
  is_default boolean default false,
  created_at timestamptz default now()
);

-- RLS: Templates
alter table prescription_templates enable row level security;
create policy "Doctors manage own templates" 
  on prescription_templates for all 
  using (auth.uid() = doctor_id);

-- ==========================================
-- 5. RPC: SMART SUGGESTIONS
-- ==========================================
-- Returns top medicines used by the *current user* for a given disease prefix
create or replace function get_frequent_meds(search_disease text)
returns table(brand text, form text, usage_count bigint) 
language plpgsql security definer
as $$
begin
  return query
  select 
    m->>'name' as brand,
    m->>'dosage' as form, -- simplified for aggregation
    count(*) as usage_count
  from prescriptions p,
       jsonb_array_elements(p.diseases) d,
       jsonb_array_elements(p.meds) m
  where 
    p.doctor_id = auth.uid() -- STRICTLY enforce current user
    and (d->>'name') ilike search_disease || '%'
  group by brand, form
  order by usage_count desc
  limit 10;
end;
$$;

-- ==========================================
-- 6. AUTH TRIGGERS (Auto-create Profile)
-- ==========================================
-- Function to handle new user creation
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, full_name, role)
  values (
    new.id,
    new.raw_user_meta_data->>'full_name',
    coalesce(new.raw_user_meta_data->>'role', 'doctor') -- Default to doctor if missing
  );
  return new;
end;
$$;

-- Trigger to call the function on new auth.users
create or replace trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- ==========================================
-- 7. STORAGE & TEMPLATES UPDATE
-- ==========================================
-- Add PDF path to templates
alter table prescription_templates 
add column if not exists background_pdf_path text;

-- Create Storage Bucket 'templates'
insert into storage.buckets (id, name, public)
values ('templates', 'templates', true)
on conflict (id) do nothing;

-- RLS for Storage
create policy "Doctors can upload templates"
on storage.objects for insert
with check ( bucket_id = 'templates' and auth.uid() = owner );

create policy "Doctors can update own templates"
on storage.objects for update
with check ( bucket_id = 'templates' and auth.uid() = owner );

create policy "Anyone can read templates"
on storage.objects for select
using ( bucket_id = 'templates' );
